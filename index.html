<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Pyramid Counter ‚Äî Pro</title>
<style>
  :root{
    --card-w:420px;
    --bg-1:#0b1116;--bg-2:#081018;
    --muted:#9fa6ad;
    --accent-a:#0b84ff;--accent-b:#3299ff;
    --outline:rgba(255,255,255,0.08);
    --input-bg: rgba(255,255,255,0.035);
    --input-border: rgba(255,255,255,0.10);
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-1),var(--bg-2));font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;color:#eef2f3;-webkit-font-smoothing:antialiased}
  .center{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:14px;box-sizing:border-box;}
  .card{width:100%;max-width:var(--card-w);border-radius:18px;padding:12px 14px 20px;box-sizing:border-box;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid var(--outline);box-shadow:0 18px 50px rgba(2,6,23,0.65);position:relative;}

  /* TOP BAR: icons only (right) */
  .topbar{display:flex;align-items:center;padding:8px 6px 6px;}
  .topbar .spacer{flex:1}
  .icons-right{display:flex;gap:8px;align-items:center}
  .icon{width:36px;height:36px;border-radius:50%;display:grid;place-items:center;border:1px solid var(--outline);background:rgba(0,0,0,0.22);cursor:pointer;font-size:18px;box-shadow:0 6px 18px rgba(0,0,0,0.45);}

  /* BELOW TOP BAR: inputs row (labels) */
  .inputs-row{display:flex;align-items:center;gap:14px;padding:8px 6px 12px;justify-content:center;flex-wrap:wrap;}
  .input-col{display:flex;flex-direction:column;gap:6px;align-items:flex-start}
  .input-label{font-size:13px;color:var(--muted)}
  .inputs-row input[type=number], .inputs-row select{
    padding:10px 12px;border-radius:10px;border:1px solid var(--input-border);
    background:var(--input-bg);color:#fff;font-size:15px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.45) inset;
  }
  /* max input fits two digits */
  #maxInput{ width:56px; text-align:center; }

  /* main area */
  .main{display:flex;gap:12px;align-items:center;justify-content:center;margin-top:6px;margin-bottom:6px;flex-direction:column}
  .btn-area{position:relative; width:170px; height:170px; display:flex;align-items:center;justify-content:center;margin-top:6px;}
  button.big{width:130px;height:130px;border-radius:50%;border:1px solid var(--outline);font-size:36px;font-weight:800;color:#fff;background:linear-gradient(180deg,var(--accent-a),var(--accent-b));box-shadow:0 18px 34px rgba(2,6,23,0.6), inset 0 6px 14px rgba(255,255,255,0.03);transition:transform 140ms}
  button.big:active{transform:translateY(3px) scale(.992)}
  button.big.disabled{opacity:.78;pointer-events:none}

  /* ring smaller and thin */
  .ring-svg{position:absolute;width:190px;height:190px;left:50%;top:50%;transform:translate(-50%,-50%);pointer-events:none}
  .ring-svg circle{transition:stroke 120ms linear;stroke-width:3}

  /* instruction larger */
  .instruction{width:100%;text-align:center;font-weight:900;font-size:34px;color:#fff;margin-top:6px;margin-bottom:6px;display:flex;align-items:center;justify-content:center;gap:10px}
  .instruction .exercise{color:#ffdca3;font-weight:900}
  .fade{animation:fadeIn 340ms ease}
  @keyframes fadeIn{from{opacity:0;transform:translateY(-6px)}to{opacity:1;transform:none}}

  .digital{width:calc(100% - 24px);margin:8px auto;padding:12px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));border:1px solid var(--outline);text-align:center}
  .digital .time{font-size:24px;font-weight:800}
  .subrow{display:flex;gap:12px;align-items:center;justify-content:center;margin-top:8px}
  .small-box{padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02);min-width:100px;text-align:center}
  .small-title{font-size:12px;color:var(--muted);margin-bottom:4px}
  .small-val{font-weight:700}

  .step{ text-align:center;color:var(--muted);font-size:13px;margin-top:8px }

  .actions{display:flex;gap:10px;justify-content:center;margin-top:10px}
  .btn{padding:8px 12px;border-radius:10px;border:none;font-weight:700;cursor:pointer}
  .btn.secondary{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.06)}
  .btn.primary{background:linear-gradient(180deg,var(--accent-a),var(--accent-b));color:#fff;border:1px solid rgba(255,255,255,0.06)}

  /* popups */
  .overlay{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.92);z-index:60;color:#fff;padding:20px;box-sizing:border-box;overflow:auto}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:16px;border-radius:12px;max-width:720px;margin:20px auto;border:1px solid var(--outline)}

  @media (max-width:420px){
    :root{--card-w:92vw}
    .instruction{font-size:28px}
    button.big{width:170px;height:170px;font-size:44px}
    .btn-area{width:200px;height:200px}
    .ring-svg{width:250px;height:250px}
    #maxInput{ width:66px; }
  }

  /* small ripple */
  .ripple{position:absolute;border-radius:50%;transform:translate(-50%,-50%) scale(0);background:rgba(255,255,255,0.12);pointer-events:none;animation:ripple 700ms ease-out;}
  @keyframes ripple{to{transform:translate(-50%,-50%) scale(3.2);opacity:0}}
</style>
</head>
<body>
  <div class="center">
    <div class="card" role="application" aria-label="Pyramid Counter">

      <!-- TOP BAR: icons only (right) -->
      <div class="topbar">
        <div class="spacer"></div>
        <div class="icons-right">
          <div id="settingsIcon" class="icon" title="Settings">‚öôÔ∏è</div>
          <div id="soundIcon" class="icon" title="Toggle sound">üîä</div>
          <div id="helpIcon" class="icon" title="Help">?</div>
        </div>
      </div>

      <!-- INPUTS ROW: under top bar with labels -->
      <div class="inputs-row">
        <div class="input-col">
          <div class="input-label">Max rep</div>
          <input id="maxInput" type="number" min="1" max="99" value="10" aria-label="Maximum pyramid number" />
        </div>
        <div class="input-col">
          <div class="input-label">Exercise type</div>
          <select id="modeSelect" aria-label="Mode">
            <option value="squats">Squats</option>
            <option value="pushups">Push-ups</option>
            <option value="pullups">Pull-ups</option>
            <option value="situps">Sit-ups</option>
            <option value="burpees">Burpees</option>
            <option value="custom">Custom</option>
          </select>
        </div>
      </div>

      <!-- instruction -->
      <div class="instruction" id="instructionText" aria-live="polite">
        <span class="verb">Complete</span>
        <span class="count" id="instrCount">-</span>
        <span class="exercise" id="instrExercise">-</span>
      </div>

      <!-- main: ring + button + digital -->
      <div class="main" role="region" aria-label="Counter area">
        <div class="btn-area">
          <svg class="ring-svg" viewBox="0 0 160 160" aria-hidden="true">
            <defs><linearGradient id="rg" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#00ff7f"/><stop offset="55%" stop-color="#ffd400"/><stop offset="100%" stop-color="#ff3b3b"/></linearGradient></defs>
            <g transform="translate(80,80)">
              <circle id="baseRing" r="54" fill="none" stroke="rgba(255,255,255,0.04)"/>
              <circle id="prog" r="54" fill="none" stroke="url(#rg)" stroke-linecap="round" stroke-dasharray="340" stroke-dashoffset="340" transform="rotate(-90)"/>
            </g>
          </svg>

          <button id="bigBtn" class="big" aria-label="Advance pyramid">Start</button>
          <div id="rippleContainer" aria-hidden="true"></div>
        </div>

        <div class="digital" id="digitalClock">
          <div class="time" id="countdown">00:00</div>
          <div class="label" id="countdownLabel">Remaining / Stopwatch</div>

          <div class="subrow" style="margin-top:10px">
            <div class="small-box">
              <div class="small-title">Level</div>
              <div class="small-val" id="levelDisplay">Beginner</div>
            </div>
            <div class="small-box">
              <div class="small-title">Elapsed</div>
              <div class="small-val" id="elapsedDisplay">00:00</div>
            </div>
            <div class="small-box">
              <div class="small-title">Total</div>
              <div class="small-val" id="totalRepsDisplay">0</div>
            </div>
          </div>
        </div>
      </div>

      <div class="step" id="stepText">Step 0 of 0</div>

      <div class="actions">
        <button id="resetBtn" class="btn secondary">Reset</button>
        <button id="autoBtn" class="btn primary">Auto</button>
      </div>

      <!-- popups -->
      <div id="helpPopup" class="overlay" role="dialog" aria-modal="true">
        <div class="panel">
          <h2>Help</h2>
          <p>Set Max and Mode below the top icons. Manual: tap the big button to start/finish each step (stopwatch). Auto runs 1..max..1 once and stops.</p>
          <div style="text-align:right"><button id="closeHelp" class="btn primary">Close</button></div>
        </div>
      </div>

      <div id="settingsPopup" class="overlay" role="dialog" aria-modal="true">
        <div class="panel">
          <h2>Settings</h2>
          <div style="display:flex;flex-direction:column;gap:12px">
            <div>
              <strong>User level</strong><br>
              <label><input type="radio" name="level" value="athlete"> Athlete</label><br>
              <label><input type="radio" name="level" value="intermediate"> Intermediate</label><br>
              <label><input type="radio" name="level" value="low"> Low</label><br>
              <label><input type="radio" name="level" value="beginner" checked> Beginner</label>
            </div>
            <div>
              <strong>Custom seconds-per-rep</strong><br>
              <input id="customSecondsPerRep" type="number" min="0.1" step="0.1" placeholder="seconds per rep"/>
            </div>
            <div>
              <strong>Rest seconds per rep</strong><br>
              <input id="restPerRepSec" type="number" min="1" step="0.5" value="10"/>
            </div>
            <div>
              <strong>Custom exercise name</strong><br>
              <input id="customExerciseName" type="text" placeholder="e.g. 'glute bridges'"/>
            </div>
            <div style="text-align:right"><button id="closeSettings" class="btn primary">Close</button></div>
          </div>
        </div>
      </div>

      <!-- audio -->
      <audio id="clickAudio" src="click-button.mp3" preload="auto"></audio>
      <audio id="progressAudio" src="progress-sound.mp3" preload="auto"></audio>
      <audio id="helpAudio" src="help-button.mp3" preload="auto"></audio>

    </div>
  </div>

<script>
(function(){
  // elements
  const maxInput = document.getElementById('maxInput');
  const modeSelect = document.getElementById('modeSelect');
  const bigBtn = document.getElementById('bigBtn');
  const prog = document.getElementById('prog');
  const instrCount = document.getElementById('instrCount');
  const instrExercise = document.getElementById('instrExercise');
  const instructionText = document.getElementById('instructionText');
  const countdownEl = document.getElementById('countdown');
  const stepText = document.getElementById('stepText');
  const resetBtn = document.getElementById('resetBtn');
  const autoBtn = document.getElementById('autoBtn');

  const clickAudio = document.getElementById('clickAudio');
  const progressAudio = document.getElementById('progressAudio');
  const helpAudio = document.getElementById('helpAudio');

  const settingsIcon = document.getElementById('settingsIcon');
  const soundIcon = document.getElementById('soundIcon');
  const helpIcon = document.getElementById('helpIcon');
  const helpPopup = document.getElementById('helpPopup');
  const closeHelp = document.getElementById('closeHelp');
  const settingsPopup = document.getElementById('settingsPopup');
  const closeSettings = document.getElementById('closeSettings');

  const customSecondsPerRepInput = document.getElementById('customSecondsPerRep');
  const restPerRepSecInput = document.getElementById('restPerRepSec');
  const customExerciseNameInput = document.getElementById('customExerciseName');
  const levelRadios = document.querySelectorAll('input[name="level"]');

  const levelDisplay = document.getElementById('levelDisplay');
  const elapsedDisplay = document.getElementById('elapsedDisplay');
  const totalRepsDisplay = document.getElementById('totalRepsDisplay');

  // state
  let max = Math.max(1, parseInt(maxInput.value) || 10);
  let current = 0;
  let dir = 1;
  let autoRunning = false;
  let tickTimer = null;
  let soundOn = true;
  let userLevel = 'beginner';
  let manualTimer = null;
  let manualStart = 0;
  let manualElapsedSec = 0;
  let manualFinished = false;

  // overall elapsed timer
  let overallTimer = null;
  let overallStart = 0;
  let overallElapsedSec = 0;

  // total reps tracked
  let totalReps = 0;

  // ring constants (r=54)
  const R = 54;
  const CIRC = 2 * Math.PI * R;
  prog.style.strokeDasharray = CIRC;
  prog.style.strokeDashoffset = CIRC;

  // helpers
  function fmtSecondsMMSS(s){ s = Math.max(0, Math.round(s)); const m = Math.floor(s/60); const sec = s%60; return String(m).padStart(2,'0')+':'+String(sec).padStart(2,'0'); }
  function colorFor(val,maxv){ if (maxv<=1) return 'hsl(120,100%,50%)'; const ratio = Math.max(0,Math.min(1,val/maxv)); const hue = 120 - (120*ratio); return `hsl(${hue},100%,45%)`; }

  // save/load
  function saveState(){ const s={ max, current, dir, userLevel, customSecondsPerRep: customSecondsPerRepInput.value, restPerRepSec: restPerRepSecInput.value, customExerciseName: customExerciseNameInput.value, soundOn }; try{ localStorage.setItem('pyr_v_totals', JSON.stringify(s)); }catch(e){} }
  function loadState(){ try{ const s = JSON.parse(localStorage.getItem('pyr_v_totals')||'{}'); if(s && s.max){ max = s.max; maxInput.value = max; } if(s && typeof s.current==='number'){ current = s.current; dir = s.dir || 1; } if(s && s.userLevel) userLevel = s.userLevel; if(s && s.customSecondsPerRep) customSecondsPerRepInput.value = s.customSecondsPerRep; if(s && s.restPerRepSec) restPerRepSecInput.value = s.restPerRepSec; if(s && s.customExerciseName) customExerciseNameInput.value = s.customExerciseName; if(s && typeof s.soundOn==='boolean') soundOn = s.soundOn; soundIcon.textContent = soundOn ? 'üîä' : 'üîá'; levelRadios.forEach(r=>{ if(r.value===userLevel) r.checked=true; }); }catch(e){} updateLevelDisplay(); }

  // timings
  function baseSecondsPerRepForMode(){ const m = modeSelect.value; if(m==='squats') return 3.0; if(m==='pushups') return 2.0; if(m==='pullups') return 2.5; if(m==='situps') return 2.5; if(m==='burpees') return 3.0; if(m==='custom'){ const v=parseFloat(customSecondsPerRepInput.value); return (isFinite(v)&&v>0)?v:2.0 } return 2.0; }
  function levelMultiplier(){ switch(userLevel){ case 'athlete':return .75; case 'intermediate':return 1; case 'low':return 1.2; case 'beginner':return 1.45; default:return 1; } }
  function exerciseSecondsForNumber(n){ return baseSecondsPerRepForMode() * levelMultiplier() * n; }
  function restSecondsForNumber(n){ const rUnit = parseFloat(restPerRepSecInput.value); const r = (isFinite(rUnit)&&rUnit>0)?rUnit:10; const lvl = (userLevel==='athlete')?0.8:(userLevel==='beginner')?1.4:(userLevel==='low')?1.2:1.0; return r*lvl*n; }

  // instruction
  function currentExerciseName(){ const mode = modeSelect.value; if(mode==='custom'){ const t=(customExerciseNameInput.value||'').trim(); return t? t : 'exercise'; } const opt = modeSelect.options[modeSelect.selectedIndex]; return opt ? opt.text.toLowerCase() : mode; }
  function showInstruction(n){ instrCount.textContent = n===0?'-':n; instrExercise.textContent = n===0?'-':currentExerciseName(); instructionText.classList.remove('fade'); void instructionText.offsetWidth; instructionText.classList.add('fade'); }

  // update UI
  function updateUI(){ showInstruction(current); stepText.textContent = `Step ${current===0?0:current} of ${max*2-1}`; if(!autoRunning){ const pct = Math.max(0,Math.min(1,(current/Math.max(1,max)))); prog.style.strokeDashoffset = CIRC*(1-pct); prog.style.stroke = colorFor(current,max); if(!manualTimer) countdownEl.textContent='00:00'; bigBtn.classList.remove('disabled'); bigBtn.textContent = current===0? 'Start' : String(current); } else { bigBtn.classList.add('disabled'); bigBtn.textContent = current===0? '‚Äî' : String(current); } saveState(); updateLevelDisplay(); updateTotalDisplay(); }

  // show level on main screen
  function updateLevelDisplay(){ levelDisplay.textContent = userLevel.charAt(0).toUpperCase() + userLevel.slice(1); }

  // update total display
  function updateTotalDisplay(){ totalRepsDisplay.textContent = String(totalReps); }

  // overall elapsed timer functions
  function startOverallTimer(){ stopOverallTimer(); overallStart = performance.now(); overallElapsedSec = 0; elapsedDisplay.textContent = fmtSecondsMMSS(0); overallTimer = setInterval(()=>{ const s = Math.floor((performance.now() - overallStart)/1000); if (s !== overallElapsedSec){ overallElapsedSec = s; elapsedDisplay.textContent = fmtSecondsMMSS(overallElapsedSec); } }, 300); }
  function stopOverallTimer(){ if (overallTimer){ clearInterval(overallTimer); overallTimer = null; } }
  function resetOverallTimer(){ stopOverallTimer(); overallElapsedSec = 0; elapsedDisplay.textContent = fmtSecondsMMSS(0); }

  // audio
  function playIfOn(audioEl){ if(!soundOn) return; try{ audioEl.currentTime=0; audioEl.play().catch(()=>{});}catch(e){} }

  // manual stopwatch
  function startManualStopwatch(){ stopManualStopwatch(); manualStart = performance.now(); manualElapsedSec = 0; countdownEl.textContent = fmtSecondsMMSS(0); manualTimer = setInterval(()=>{ const elapsedMs = performance.now()-manualStart; const elapsedSec = Math.floor(elapsedMs/1000); if(elapsedSec !== manualElapsedSec){ manualElapsedSec = elapsedSec; countdownEl.textContent = fmtSecondsMMSS(manualElapsedSec); } },200); }
  function stopManualStopwatch(){ if(manualTimer){ clearInterval(manualTimer); manualTimer=null; } }

  // manual behaviour (1..max..1 then stop). Removed automatic reset on tap after finish.
  function manualAdvance_StartOrNext(){
    if(current===0){ current=1; dir=1; playIfOn(clickAudio); startManualStopwatch(); startOverallTimer(); updateUI(); return; }
    // user finished current step: add current to total, stop stopwatch
    playIfOn(clickAudio);
    stopManualStopwatch();
    totalReps += current;
    updateTotalDisplay();

    if(dir===1 && current<max){ current=current+1; startManualStopwatch(); updateUI(); return; }
    if(dir===1 && current===max){ dir=-1; if(max>1){ current=current+dir; startManualStopwatch(); updateUI(); return; } else { finishManual(); return; } }
    if(dir===-1 && current>1){ current=current+dir; startManualStopwatch(); updateUI(); return; }
    if(dir===-1 && current===1){ finishManual(); return; }
  }
  function finishManual(){ stopManualStopwatch(); manualFinished=true; stopOverallTimer(); bigBtn.textContent='Done'; current=1; dir=1; updateUI(); }

  // build pyramid sequence 1..max..1
  function buildPyramidSequence(maxN){ const seq=[]; for(let i=1;i<=maxN;i++) seq.push(i); for(let j=maxN-1;j>=1;j--) seq.push(j); return seq; }

  // auto run once (accumulate totals live), DO NOT auto-reset at end ‚Äî show Done and wait for user Reset
  function startAuto(){
    stopManualStopwatch();
    manualFinished=false;
    if(current===0) current=1;
    autoRunning=true; autoBtn.textContent='Stop'; bigBtn.classList.add('disabled');
    startOverallTimer();
    const seq = buildPyramidSequence(max); let idx = seq.indexOf(current); if(idx<0) idx=0;

    function runNext(){
      if(!autoRunning) return;
      const n = seq[idx];
      const ex = exerciseSecondsForNumber(n);
      const rest = restSecondsForNumber(n);
      const total = Math.max(200, Math.round((ex+rest)*1000));
      const interval = 100; const steps = Math.max(1, Math.round(total/interval)); let step = 0;
      playIfOn(progressAudio);
      current = n; updateUI(); stepText.textContent = `Step ${n} of ${max*2-1}`;

      function tick(){
        if(!autoRunning) return;
        step++;
        const pct = Math.min(1, step/steps);
        prog.style.strokeDashoffset = CIRC*(1-pct);
        prog.style.stroke = colorFor(n,max);
        const remainingMs = Math.max(0, Math.round(total - step*interval));
        countdownEl.textContent = fmtSecondsMMSS(Math.ceil(remainingMs/1000));
        if(step < steps){ tickTimer = setTimeout(tick, interval); }
        else {
          // finished this step: add n to total
          totalReps += n;
          updateTotalDisplay();
          idx++;
          if(idx >= seq.length){
            // finished whole pyramid: stop timers and show Done ‚Äî do NOT auto-reset
            autoRunning = false;
            autoBtn.textContent = 'Auto';
            bigBtn.classList.remove('disabled');
            manualFinished = true;
            stopOverallTimer();
            bigBtn.textContent = 'Done';
            countdownEl.textContent = '00:00';
            updateUI();
            return;
          }
          tickTimer = setTimeout(()=>{ runNext(); }, 140);
        }
      }
      countdownEl.textContent = fmtSecondsMMSS(Math.ceil(total/1000));
      prog.style.stroke = colorFor(n,max);
      tick();
    }
    runNext();
  }

  function stopAuto(){ if(tickTimer){ clearTimeout(tickTimer); tickTimer=null; } autoRunning=false; autoBtn.textContent='Auto'; bigBtn.classList.remove('disabled'); countdownEl.textContent='00:00'; stopOverallTimer(); updateUI(); }

  // reset helper
  function doReset(){ if(tickTimer){ clearTimeout(tickTimer); tickTimer=null; } if(manualTimer){ clearInterval(manualTimer); manualTimer=null; } autoRunning=false; autoBtn.textContent='Auto'; current=0; dir=1; manualFinished=false; countdownEl.textContent='00:00'; prog.style.strokeDashoffset = CIRC; bigBtn.classList.remove('disabled'); bigBtn.textContent='Start'; stopOverallTimer(); resetOverallTimer(); totalReps = 0; updateTotalDisplay(); updateUI(); }

  // clamp max input to 1..99 (two digits)
  function clampMaxInput(){
    let v = parseInt(maxInput.value, 10);
    if (!isFinite(v) || v < 1) v = 1;
    if (v > 99) v = 99;
    max = v;
    maxInput.value = String(v);
    if (current > max) current = max;
    prog.style.strokeDashoffset = CIRC * (1 - (current / Math.max(1, max)));
    updateUI();
  }

  // events
  bigBtn.addEventListener('pointerdown', (ev)=>{ ev.preventDefault(); const rc = document.getElementById('rippleContainer'); const r=document.createElement('div'); r.className='ripple'; const rect = ev.currentTarget.getBoundingClientRect(); const x=(ev.clientX-rect.left)||rect.width/2; const y=(ev.clientY-rect.top)||rect.height/2; r.style.left=x+'px'; r.style.top=y+'px'; r.style.width='16px'; r.style.height='16px'; rc.appendChild(r); r.addEventListener('animationend', ()=> r.remove()); if(autoRunning) return; if(manualFinished) return; manualAdvance_StartOrNext(); });

  resetBtn.addEventListener('click', doReset);
  autoBtn.addEventListener('click', ()=>{ if(!autoRunning) startAuto(); else stopAuto(); });

  soundIcon.addEventListener('click', ()=>{ soundOn = !soundOn; soundIcon.textContent = soundOn ? 'üîä' : 'üîá'; saveState(); });
  helpIcon.addEventListener('click', ()=>{ playIfOn(helpAudio); helpPopup.style.display='block'; });
  closeHelp.addEventListener('click', ()=>{ helpPopup.style.display='none'; });
  settingsIcon.addEventListener('click', ()=>{ settingsPopup.style.display='block'; });
  closeSettings.addEventListener('click', ()=>{ settingsPopup.style.display='none'; });

  levelRadios.forEach(r=> r.addEventListener('change', ()=>{ if(r.checked){ userLevel = r.value; updateLevelDisplay(); saveState(); } }));
  customSecondsPerRepInput.addEventListener('change', ()=> saveState());
  restPerRepSecInput.addEventListener('change', ()=> saveState());
  customExerciseNameInput.addEventListener('change', ()=> saveState());
  modeSelect.addEventListener('change', ()=>{ updateUI(); saveState(); });

  // clamp on change / blur / input
  maxInput.addEventListener('change', clampMaxInput);
  maxInput.addEventListener('blur', clampMaxInput);
  maxInput.addEventListener('input', ()=> {
    const v = maxInput.value.replace(/[^\d]/g, '').slice(0,2);
    maxInput.value = v === '' ? '' : String(parseInt(v,10));
  });

  // init
  loadState();
  clampMaxInput();
  totalReps = 0; updateTotalDisplay();
  updateUI();
  prog.style.stroke = colorFor(current, max);
})();
</script>
</body>
</html>